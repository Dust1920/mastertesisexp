[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Tesis de Maestría",
    "section": "",
    "text": "1 Introducción\nEn este libro veremos la continuación del modelo visto en la Tesis de Licenciatura.\n\\[\\begin{align*}\n\\mathrm{d}z & =\\omega\\mathrm{d}t\\\\\n\\mathrm{d}\\omega & =\\left(b\\left(z\\right)-\\dfrac{\\omega}{\\tau_{w}}\\right)\\mathrm{d}t+b_{w}\\mathrm{d}W\n\\end{align*}\\]\nDonde vimos que, por ejemplo \\(q_t = q_v + q_r\\). En este modelo consideraremos quitaremos tal restricción, y agregaremos la dependiencia temporal, es decir \\(q_v(z)\\to q_v(z, t)\\). Esto convierte el sistema de ecuaciones diferenciales ordinarias en un sistema de ecuaciones diferenciales parciales."
  },
  {
    "objectID": "theory.html",
    "href": "theory.html",
    "title": "2  Teoría Fisica",
    "section": "",
    "text": "3 Teoria Númerica"
  },
  {
    "objectID": "theory.html#adimensionalizacion",
    "href": "theory.html#adimensionalizacion",
    "title": "2  Teoría Fisica",
    "section": "3.1 Adimensionalizacion",
    "text": "3.1 Adimensionalizacion\nAl momento de trabajar con modelos físicos, en este caso atmosféricos, es importante tener cuidado al trabajar las unidades para evitar errores. Uno de los métodos más usados es la eliminación de las unidades."
  },
  {
    "objectID": "theory.html#discretizacion",
    "href": "theory.html#discretizacion",
    "title": "2  Teoría Fisica",
    "section": "3.2 Discretizacion",
    "text": "3.2 Discretizacion\n\n3.2.1 Malla (Regiones Rectangulares)\nEn el modelo trabajamos dentro de la tropopausa, por lo tanto \\(Z = [0,15]\\) y consideremos \\(T=[0, t],t\\in\\mathbb{R}\\). Por lo tanto, nuestra zona de trabajo es \\(U = Z\\times T\\), donde cada \\(u\\in U\\) es de la forma \\(u=(z,t)\\). Ahora, definiremos \\(n_z,n_t\\in\\mathbb{N}\\), tales que \\(n_z,n_t&gt;0\\). \\(n_z\\) nos dira el número de pedazos en los que será dividido \\(Z\\) y de igual forma con \\(n_t\\) para \\(T\\).\nSi \\(n_z = 2\\), entonces existe \\(z^*\\) tal que \\(Z = [0,z^*] \\cup [z^*,15]\\), llamando \\(z_0 = 0\\) y \\(z_f = 15\\). Decimos que la colección \\(P_Z = \\{z_0,z^*,z_f\\}\\) forman una partición de \\(Z\\). Todo esto aplica de igual forma para \\(T\\). Entonces, llamaremos malla (o ‘grid’ traducido al ingles) al conjunto \\(G\\), donde \\[\nG = P_Z \\times P_T,\n\\]\ndonde \\(P_Z\\) y \\(P_T\\) son particiones de \\(Z\\) y \\(T\\) respectivamente.\nDentro de una partición \\(P=\\{x_0,\\ldots,x_n\\}\\) llamaremos \\(\\Delta x_k = x_{k+1}-x_k, n-1\\geq k\\geq 0\\). Entonces para \\(P_Z\\) y \\(P_T\\) existe \\(\\Delta z_k,\\Delta t_k\\) respectivamente. Entonces, es claro que \\[\\begin{align*}\nt_{k} & =t_{0}+\\sum_{i=0}^{k-1}\\Delta t_{k}\\\\\nz_{k} & =z_{0}+\\sum_{i=0}^{k-1}\\Delta z_{k}\n\\end{align*}\\]\nEntonces, entonces para cada \\(u\\in G\\) existen indices \\(i,j\\) tales que\n\\[\nu\\in G\\Rightarrow u(z,t) = u(z_i,t_j) = u^i_j\n\\]\n\n\n3.2.2 Método Upwind\nUna vez definida la malla, y conociendo el sistema a resolver, debemos revisar como vamos a resolver el sistema. Para ello usaremos una versión del método upwind la cual consta de 2 elementos.\n\nDiferencias Finitas\nCriterio CFL\n\n\n3.2.2.1 Diferencias Finitas\nRecordando la definición de derivada. \\[\nf'_+(x) = \\lim_{h\\to 0} \\dfrac{f(x + h)-f(x)}{h}\n\\]\nEs claro que, \\[\nf'(x) \\approx \\dfrac{f(x + h)-f(x)}{h}.\n\\]\nTambién, según la situación pueden usarse variaciones para aproximarla.\n\\[\nf'_{-}(x) = \\dfrac{f(x)-f(x - h)}{h},f'_{\\cdot}(x) = \\dfrac{f'_{+}(x) + f'_{-}(x)}{2}\n\\]\nSin embargo, esto es para funciones reales. (\\(f:\\mathbb{R}\\to \\mathbb{R}\\)). Para nuestro caso \\(f:G\\to \\mathbb{R}\\), requeriremos las derivadas parciales, tales que sin detalles pueden aproximarse mediante la siguiente fórmula. \\[\n\\partial_z f(z,t)\\approx \\dfrac{f(z+h,t)-f(z,t)}{h},\\partial_t f(z,t) \\approx \\dfrac{f(z,t+h)-f(z,t)}{h}\n\\]\n\n\n3.2.2.2"
  },
  {
    "objectID": "model1.html",
    "href": "model1.html",
    "title": "3  Modelo 1: Etapa 1",
    "section": "",
    "text": "Al estar recorriendo el modelo por submodelos, supondremos la velocidad constante. \\[\n\\omega\\left(z,t\\right)=1,\\forall\\left(z,t\\right)\\in\\mathbb{R}^{2}\n\\]\nEntonces, el sistema queda como sigue \\[\\begin{align*}\n\\omega\\left(z,t\\right) & =1\\\\\n\\partial_{t}\\left(\\theta\\right)+\\partial_{z}\\left(\\omega\\theta\\right) & =0\\\\\n\\partial_{t}\\left(q_{v}\\right)+\\partial_{z}\\left(\\omega q_{v}\\right) & =0\\\\\n\\partial_{t}\\left(q_{r}\\right)+\\partial_{z}\\left(\\omega q_{r}\\right) & =0\\\\\n\\partial_{t}\\left(q_{N}\\right)+\\partial_{z}\\left(\\omega q_{N}\\right) & =0\n\\end{align*}\\]\nEntonces, pretendemos resolver un sistema desacoplado donde cada variable representa un problema de transporte.\nPara ello. partimos importando las librerías básicas y los parámetros definidos para el modelo.\n\nimport numpy as np  \nimport parameters as p\n\nEntonces, proseguimos con la “entrada” del modelo.\n\nz_0 = 0  # Km, nunca olvide las unidades...\nz_0 = z_0 / p.length_scale\n\nz_f = 15\nz_f = z_f / p.length_scale\n\nprint(z_0, z_f)\n\n0.0 1.5\n\n\nUna vez definida \\(Z = [z_0,z_f]\\), seguimos con \\(n_z\\), en nuestro caso, comenzaremos con \\(n_z = 150\\).\n\nn_z = 150\n\nheight = np.linspace(z_0,z_f,n_z)\ndelta_z = height[1] - height[0]\n\nprint(n_z, delta_z)\n\n150 0.010067114093959731\n\n\nEn nuestro caso, al usar la función “linspace”, dados por sentado que \\(\\Delta z\\) es constante, es decir, \\(\\Delta z_k=c,c\\in\\mathbb{R}\\).\nAhora, seguimos con el area de trabajo.\n\nvariables = ['omega','theta','qv','qr','qn']\n\nworkspace = np.zeros((n_z,len(variables)))\n\nEn nuestro caso, nuestra areá de trabajo es una matriz de \\(n_z\\times n_v\\) donde \\(n_v\\) es el número de variables. Seguido con las condiciones iniciales, para ello, de nuevo llamamos a las librerías adecuadas.\n\nimport matplotlib.pyplot as plt\nimport init_functions as init\n\nPara el primer modelo. Usaremos funciones escalonadas o de Heaviside.\n\\[\nU(x) =\n\\begin{cases}\n0& x&lt;0\\\\\n1& x\\geq 0\n\\end{cases}\n\\]\n\ny = np.array([init.heaviside(i) for i in height])\nplt.plot(y * p.velocity_scale, p.length_scale * height)\nplt.ylim([0.0,15.0])\nplt.xlabel('temperature')\nplt.ylabel('height')\n\nText(0, 0.5, 'height')\n\n\n\n\n\nEn este caso era claro que saldría constante, por esto vamos a trasladar la función una distancia de \\(a\\), además sirve para comentar que al estar tratando con alturas, es más conveniente gráficar con el formato anterior. \\((f(z),z)\\).\n\n# Vamos a desplazar la grafica 3 unidades. \na_omega = 3\na_omega = a_omega / p.velocity_scale\na_theta = 3\na_theta = a_theta / p.temperature_scale\na_qv = 300\na_qv = a_qv / p.ratio_scale\na_qr = 300\na_qr = a_qr / p.ratio_scale\na_qn = 300\na_qn = a_qn / p.ratio_scale\n\nprint(a_omega, a_theta, a_qv, a_qr, a_qn)\n\n0.27 1.0 0.3 0.3 0.3\n\n\nRecordando que \\[\nU_a(x) =\n\\begin{cases}\n0& x&lt;a\\\\\n1& x\\geq a\n\\end{cases} = U(x-a),\\forall a\\in \\mathbb{R}\n\\]\npodemos graficar \\(\\omega\\).\n\ny_omega = np.array([init.heaviside(i - a_theta) for i in height])\nplt.plot(y_omega * p.temperature_scale, p.length_scale * height)\nplt.ylim([0.0,15.0])\nplt.xlabel('temperature')\nplt.ylabel('height')\n\nText(0, 0.5, 'height')\n\n\n\n\n\nEntonces, ahora podemos graficar todas en conjunto. Para eso usaremos una función auxiliar\n\ndef system_plots(workspace, y):\n    velocity = workspace[:, 0]\n    temperature = workspace[:, 1]\n    vapor = workspace[:, 2]\n    water = workspace[:, 3]\n    core = workspace[:, 4]\n    wt_plots, ax = plt.subplots(1, 2)\n    qvrn_plots, axq = plt.subplots(2, 2)\n    ax[0].plot(velocity * p.velocity_scale, y * p.length_scale)\n    ax[0].set_xlabel('velocity ('r'$ms^{-1}$'')')\n    ax[1].plot(temperature * p.temperature_scale, y * p.length_scale)\n    ax[1].set_xlabel('temperature (K)')\n    axq[0, 0].plot(velocity * p.velocity_scale, y * p.length_scale)\n    axq[0, 0].set_xlabel('velocity ('r'$ms^{-1}$'')')\n    axq[0, 1].plot(vapor * p.ratio_scale, y * p.length_scale)\n    axq[0, 1].set_xlabel('vapor ('r'$g(kg)^{-1}$'')')\n    axq[1, 0].plot(water * p.ratio_scale, y * p.length_scale)\n    axq[1, 0].set_xlabel('liquid ('r'$g(kg)^{-1}$'')')\n    axq[1, 1].plot(core * p.ratio_scale, y * p.length_scale)\n    axq[1, 1].set_xlabel('cores ('r'$g(kg)^{-1}$'')')\n    plt.show()\n\nEntonces, graficamos las condiciones iniciales.\n\nv0 = 4  # Etapa 1: Velocidad Constante\nv0 = v0 / p.velocity_scale\n\nworkspace[:, 0] = v0\nworkspace[:, 1] = [init.heaviside(i - a_theta) for i in height]\nworkspace[:, 2] = [init.heaviside(i - a_qv) for i in height]\nworkspace[:, 3] = [init.heaviside(i - a_qr) for i in height]\nworkspace[:, 4] = [init.heaviside(i - a_qn) for i in height]\n\nsystem_plots(workspace, height)\n\n\n\n\n\n\n\nUna vez podemos ver las condiciones iniciales, procedemos a la implementación del método. Primero definimos \\(T=[0,t]\\) y fijamos el criterio CFL.\n\nt = 5\n\ncfl = 0.9\n\ndelta_t = cfl * delta_z\nprint(delta_t)\n\n0.009060402684563758\n\n\nUna vez definido CFL, podemos calcular \\(\\Delta_t\\) mediante la formula\n\\[\n\\Delta t = \\dfrac{\\text{CFL}}{\\Delta z}\n\\]\nPara \\(\\Delta_t\\) inicial, pero como se mencionó anteriormente, \\(\\Delta t\\) ira variando mediante la siguiente fórmula.\n\\[\n\\Delta t (c_w)= \\dfrac{\\text{CFL}}{\\Delta z} c_w\n\\]\nDonde \\(c_w\\) variará según el modelo. Aplicando el método de upwind, resolvemos el primer modelo.\n\ndef upwind_model(dt, dz, u, ve):\n    m, n = np.shape(u)\n    aux = np.zeros((m, n))\n    v = u[:, 0]\n    t = u[:, 1]\n    qv = u[:, 2]\n    qr = u[:, 3]\n    qn = u[:, 4]\n    dzt = dt / dz\n    for i in range(1, m - 1):\n        if v0 &lt; 0:\n            aux[i, 0] = ve\n            aux[i, 1] = t[i] - ve * dzt * (t[i + 1] - t[i])\n            aux[i, 2] = qv[i] - ve * dzt * (qv[i + 1] - qv[i])\n            aux[i, 3] = qr[i] - ve * dzt * (qr[i + 1] - qr[i])\n            aux[i, 4] = qn[i] - ve * dzt * (qn[i + 1] - qn[i])\n        else:\n            aux[i, 0] = ve\n            aux[i, 1] = t[i] - ve * dzt * (t[i] - t[i - 1])\n            aux[i, 2] = qv[i] - ve * dzt * (qv[i] - qv[i - 1])\n            aux[i, 3] = qr[i] - ve * dzt * (qr[i] - qr[i - 1])\n            aux[i, 4] = qn[i] - ve * dzt * (qn[i] - qn[i - 1])\n        aux[0, :] = aux[1, :]\n        aux[-1,:] = aux[-2, :]\n    return aux\n\nUna vez construido el modelo. Preparamos la implementación\n\nt_star = 0\nwhile t_star &lt; t:\n    workspace = upwind_model(delta_t, delta_z, workspace, v0)\n    dt = cfl * delta_z / np.abs(v0)\n    t_star += dt\n\nsystem_plots(workspace, height)\n\n\n\n\n\n\n\nFinalmente, una función que implemente todo lo visto.\n\ndef model1(variables,  a, v0, Z, n_z, t, cfl):\n    def heaviside(x): # Tarea, modificar model1 para que acepte diferentes\n        if x &lt; 0:        # funciones\n            y = 0\n        else:\n            y = 1\n        return y\n    height = np.linspace(Z[0],Z[1],n_z)\n    delta_z = height[1] - height[0]\n    workspace = np.zeros((n_z,len(variables)))\n\n    a_omega = a[0]\n    a_theta = a[1]\n    a_qv = a[2]\n    a_qr = a[3]\n    a_qn = a[4]\n\n    workspace[:, 0] = v0\n    workspace[:, 1] = [init.heaviside(i - a_theta) for i in height]\n    workspace[:, 2] = [init.heaviside(i - a_qv) for i in height]\n    workspace[:, 3] = [init.heaviside(i - a_qr) for i in height]\n    workspace[:, 4] = [init.heaviside(i - a_qn) for i in height]\n\n    de_t = cfl * delta_z\n   \n    t_star = 0\n    m, n = np.shape(workspace)\n    while t_star &lt; t:\n        v = workspace[:, 0]\n        temp = workspace[:, 1]\n        qv = workspace[:, 2]\n        qr = workspace[:, 3]\n        qn = workspace[:, 4]\n        aux = np.zeros((m, n))\n        dzt = de_t / delta_z\n        for i in range(1, m - 1):\n            if v0 &lt; 0:\n                aux[i, 0] = v0\n                aux[i, 1] = temp[i] - v0 * dzt * (temp[i + 1] - temp[i])\n                aux[i, 2] = qv[i] - v0 * dzt * (qv[i + 1] - qv[i])\n                aux[i, 3] = qr[i] - v0 * dzt * (qr[i + 1] - qr[i])\n                aux[i, 4] = qn[i] - v0 * dzt * (qn[i + 1] - qn[i])\n            else:\n                aux[i, 0] = v0\n                aux[i, 1] = temp[i] - v0 * dzt * (temp[i] - temp[i - 1])\n                aux[i, 2] = qv[i] - v0 * dzt * (qv[i] - qv[i - 1])\n                aux[i, 3] = qr[i] - v0 * dzt * (qr[i] - qr[i - 1])\n                aux[i, 4] = qn[i] - v0 * dzt * (qn[i] - qn[i - 1])\n            aux[0, :] = aux[1, :]\n            aux[-1,:] = aux[-2, :]\n            workspace = aux\n        dt = cfl * delta_z / np.abs(v0)\n        t_star += dt\n    return workspace\n\n\ns = model1(['omega','temp','qv','qr','qn'],\n[3,3,3,3,3], 1, [0, 15], 150, 2, 0.9)\n\nsystem_plots(s, height)\n\n\n\n\n\n\n\n\n4 Modelo 1: Etapa 2\nUna vez concluido la etapa 1, seguiremos agregando las funcionces \\(V_{\\text{T}}, V_{\\text{TN}}\\). Las cuales tienen la siguiente forma.\n\\[\\begin{align*}\nV_{\\text{T}}\\left(q_{r}\\right)= & V_{0}\\dfrac{q_{r}}{q_{*}}\\\\\nV_{\\text{TN}}\\left(q_{r}\\right)= & V_{\\text{TN}d}+\\max\\left(\\dfrac{q_{r}}{q_{*}},1\\right)\\max\\left(V_{T}\\left(q_{r}\\right)-V_{\\text{TN}d},0\\right)\n\\end{align*}\\]"
  }
]